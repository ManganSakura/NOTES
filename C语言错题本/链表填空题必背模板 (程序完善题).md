**标签：** #C语言 #链表 #程序完善 #华科期末

## 1. 节点的定义 (万恶之源)
考试通常会先定义好结构体，**看清楚变量名** (是 `next` 还是 `link`，是 `data` 还是 `value`)。

```c
typedef struct node {
    int data;
    struct node *next;
} NODE, *LINK;
````

---

## 2. 必考模式一：头插法 (Head Insertion)

**特点**：逆序建立链表 (输入 1,2,3 -> 链表 3->2->1)。 **识别关键词**：“后进先出”、“逆序”、“栈”。

> [!DANGER] 易错点 必须先把旧的头挂在新节点后面，**防止链表断裂**。

**模板代码：**

C

```
// 假设 head 指向头结点 (带头结点情况)
// 假设 new_node 是 malloc 出来的新节点
new_node->next = head->next;   // 1. 新节点以此为继
head->next = new_node;         // 2. 头结点指向新节点
```

**真题陷阱 (2022年大整数加法 inputdata 函数)：** 题目给的是指向头指针的指针 `*phd` (不带头结点的链表)。

C

```
p->next = *phd;  // 把原来的第一个节点挂在新节点后面 (千万别填 NULL!)
*phd = p;        // 更新头指针指向新节点
```

---

## 3. 必考模式二：尾插法 (Tail Insertion)

**特点**：顺序建立链表 (输入 1,2,3 -> 链表 1->2->3)。 **识别关键词**：“先进先出”、“顺序”、“队列”。 **必要条件**：必须有一个 `tail` 指针始终指向最后一个节点。

**模板代码：**

C

```
// head 是头指针，tail 初始指向 head
tail->next = new_node;  // 1. 把新节点挂在尾巴后面
tail = new_node;        // 2. 更新尾巴标签 (这一步最容易忘!)
tail->next = NULL;      // 3. 封口 (有时放在循环外做)
```

**真题对应 (2015年/2022年)：** 2022年 `exadder` 函数中空缺的 `tail = tail->next` 或者 `tail = p` 就是这一步。

---

## 4. 必考模式三：链表遍历

**场景**：输出链表、查找元素、链表长度计算。

> [!WARNING] 死循环警报 90% 的填空题错误是因为忘了写 **指针后移**！

**模板代码：**

C

```
p = head->next; // 初始化
while (p != NULL) { // 边界判断
    printf("%d", p->data); // 访问数据
    p = p->next; // <--- 这一行没写就是 0 分！
}
```

---

## 5. 内存分配 (malloc)

只要看到创建新节点，填空必定涉及 `malloc`。

**标准写法：**

C

```
p = (struct node *)malloc(sizeof(struct node));
```

- 注意 `sizeof` 里面是**结构体类型**，不是指针类型。
    
- 2019年真题 和 2022年真题都考了这个。