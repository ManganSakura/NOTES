### 一、 `<stdio.h>`：输入输出的核心

这是考试中占比最大的库，分为**控制台I/O**和**文件I/O**。

#### 1. 控制台 I/O (屏幕 & 键盘)

|**函数**|**关键点 & 考试陷阱**|
|---|---|
|**`scanf`**|1. **返回值**：返回成功读入的变量个数（不是读取的值！）。<br><br>  <br><br>2. **取地址**：除了字符串数组名，其他变量必须加 `&`。<br><br>  <br><br>3. **缓冲区**：`scanf` 读完后，换行符 `\n` 会留在缓冲区，可能影响下一个 `getchar` 或 `gets`。|
|**`printf`**|1. **格式符**：`%5d` (右对齐补空格), `%-5d` (左对齐), `%.2f` (保留2位小数)。<br><br>  <br><br>2. **返回值**：返回打印字符的个数（较少考）。|
|**`getchar`**|1. **返回类型**：是 `int` 不是 `char`（为了接收 `EOF`，即 -1）。<br><br>  <br><br>2. **作用**：常用于吃掉 `scanf` 留下的回车符。|
|**`gets`** / **`fgets`**|1. **`gets(str)`**：不安全（易溢出），读一行，**会**吃掉换行符但不存入串中。<br><br>  <br><br>2. **`fgets(str, n, stdin)`**：安全，读一行，**会**把换行符 `\n` 也存入字符串（如果有空间）。|

#### 2. 文件 I/O (`FILE *`)

这是大题（程序完善题）的重灾区。

**A. 文件的打开与关闭**

- **`FILE *fp = fopen("filename", "mode");`**
    
    - **失败检测**：必须判断 `if (fp == NULL)`。
        
    - **Mode (模式)**：
        
        - `"r"`：只读。文件必须存在，否则返回 NULL。
            
        - `"w"`：只写。文件不存在则创建，**存在则清空**（慎用）。
            
        - `"a"`：追加。写在文件末尾。
            
        - `"rb", "wb"`：二进制模式（处理图片、结构体数组等）。
            
- **`fclose(fp);`**：切记，有开必有关。
    

**B. 文件的读写 (三大套路)**

1. **字符读写 (逐个字节)**
    
    - `fgetc(fp)`：返回 `int`，读到文件尾返回 `EOF`。
        
    - `fputc(ch, fp)`：写入一个字符。
        
2. **格式化读写 (像 printf/scanf 一样)**
    
    - **`fprintf(fp, "%d %s", a, b)`**：把数据写进文本文件。
        
    - **`fscanf(fp, "%d %s", &a, b)`**：从文本文件解析数据。
        
    - **坑点**：`fscanf` 返回值也是成功读取的个数。循环读取常用 `while(fscanf(...) != EOF)` 或 `== 期望个数`。
        
3. **二进制块读写 (结构体专用)**
    
    - **`fread(ptr, size, count, fp)`**：从 fp 读 `count` 个块，每个大小 `size`，存入 `ptr`。
        
    - **`fwrite(ptr, size, count, fp)`**：把 `ptr` 里的数据写入 fp。
        
    - **返回值**：返回成功读/写的块数 (`count`)。
        

**C. 文件状态**

- **`feof(fp)`**：判断是否到了文件末尾。
    
    - **注意**：`feof` 只有在**读取失败一次后**才会变真。所以循环通常写成 `while(!feof(fp))` 内部再配合读取判断，或者直接判断读取函数的返回值。
        
- **`rewind(fp)`**：让指针回到文件开头。
    

---

### 二、 `<stdlib.h>`：内存与工具箱

#### 1. 动态内存管理 (链表必考)

- **`malloc(size)`**：在堆区分配内存。
    
    - **公式**：`Type *p = (Type *)malloc(sizeof(Type) * n);`
        
    - **单位**：字节。
        
    - **初始化**：里面是**垃圾值**。
        
- **`calloc(n, size)`**：分配内存并**自动初始化为0**。
    
- **`free(p)`**：释放内存。
    
    - **坑点**：释放后 `p` 变成悬空指针，建议 `p = NULL;`。
        

#### 2. 字符串转数字

- **`atoi(str)`**：String to Integer。如 `atoi("123")` -> `123`。
    
- **`atof(str)`**：String to Float。
    
- _注意：`itoa` 不是标准C函数，有些编译器不支持，考试尽量别用，用 `sprintf` 代替。_
    

#### 3. 其他

- **`rand()`**：产生伪随机数。
    
- **`srand(seed)`**：设置种子（通常配合 `time(0)`）。
    
- **`exit(0)`**：强制结束整个程序（不仅仅是结束当前函数）。
    

---

### 三、 `<string.h>`：字符串处理专家

> [!WARNING] 核心原则
> 
> 1. 字符串必须以 `\0` 结尾。
>     
> 2. 目标数组 (`dest`) 的空间必须足够大，否则溢出。
>     

|**函数**|**原型简化**|**考试坑点**|
|---|---|---|
|**`strlen`**|`size_t strlen(s)`|1. **不包含** `\0`。<br><br>  <br><br>2. `sizeof` 包含 `\0`。例如 `"abc"`，strlen是3，sizeof是4。|
|**`strcpy`**|`strcpy(dest, src)`|1. 会把 `src` 的 `\0` 也拷过去。<br><br>  <br><br>2. 覆盖 `dest` 原来的内容。<br><br>  <br><br>3. `dest` 必须是数组或 malloc 的空间，不能是字符串常量指针。|
|**`strcat`**|`strcat(dest, src)`|1. 从 `dest` 的 `\0` 位置开始拼接。<br><br>  <br><br>2. 自动在末尾补 `\0`。|
|**`strcmp`**|`strcmp(s1, s2)`|1. **不是比较长度，是比较字典序**（ASCII码）。<br><br>  <br><br>2. 返回值：`0` (相等), `>0` (s1大), `<0` (s1小)。<br><br>  <br><br>3. 严禁写 `if(s1==s2)`，那是比地址！|
|**`strstr`**|`strstr(haystack, needle)`|1. 在大串中找子串。<br><br>  <br><br>2. 返回子串**第一次出现地址**的指针。找不到返回 NULL。<br><br>  <br><br>3. 常用在循环查找删除中（如你刚才做的那道题）。|

---
### ⚠️ strlen 的“截断”特性
* **现象**：如果字符数组中间包含 `\0`。
* **结果**：`strlen` 计算到第一个 `\0` 即停止。
* **对比**：
    * `strlen(s)`：看**内容** (到 `\0` 截止的有效长度)。
    * `sizeof(s)`：看**地皮** (数组声明的总字节数)。
* **口诀**：**strlen 遇到 0 就跑，sizeof 雷打不动。**
### 四、 总结：考试中的“肌肉记忆”


1. **文件读取循环标准写法**：
    
    C
    
    ```
    FILE *fp = fopen("data.txt", "r");
    if(fp == NULL) { exit(1); }
    int x;
    while(fscanf(fp, "%d", &x) == 1) { // 成功读到一个整数
        // 处理 x
    }
    fclose(fp);
    ```
    
2. **创建链表节点标准写法**：
    
    C
    
    ```
    struct node *p = (struct node *)malloc(sizeof(struct node)); // 申请
    if(p == NULL) exit(1);
    p->data = ...;
    p->next = NULL; // 切记初始化
    ```
    
3. **字符串复制**：
    
    C
    
    ```
    char *s = "hello";
    char *d = (char *)malloc(strlen(s) + 1); // 切记 +1 给 \0
    strcpy(d, s);
    ```
    
