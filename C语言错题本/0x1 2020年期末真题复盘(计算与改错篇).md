**标签：** #C语言 #华科期末 #错题集 #指针 #副作用 #改错题

---

## 一、计算题：三大“潜规则”陷阱

### 1. 逗号表达式与副作用 (Sequence Points)
**错题原型：** `(a=7, b=3, a>b?a++:b++, a+b)`
**你的误区：** 认为 `a++` 和 `a+b` 是并列关系，或者忘了 `a` 变了。

> [!NOTE] 正解逻辑
> 逗号表达式是从左往右**依次执行**，**每一项的副作用都会生效**。
> 1. **初始化**：`a=7`。
> 2. **三目运算**：`7>3` 成立，执行 `a++`。
>    * **关键点**：此时内存中 `a` 的值变成了 **8**。
> 3. **最后一项**：计算 `a+b`。
>    * 使用新的 `a` (8) + `b` (3) = **11**。

### 2. 赋值运算的“右结合性”
**错题原型：** `a += a *= a` (a=7)
**你的误区：** 运算顺序搞反，或者用了旧值相加。

> [!TIP] 破题口诀
> 看到连续赋值，**永远从右向左画箭头**。
> 1. 先算右边：`a *= a` -> `a = 7*7 = 49`。(a 此时已变)
> 2. 再算左边：`a += 49` -> `49 + 49 = 98`。
> * **切记**：左边 `a+=` 里的 `a` 也是取最新值 49。

### 3. 指针的后置自增
**错题原型：** `(*p++).n`
**你的误区：** 纠结是先移位还是先取值。

> [!NOTE] 正解逻辑
> 1. `p++` 的优先级很高，但它是**后置**的。
> 2. **规则**：表达式的值是 **移动前** 的指针，但副作用是 **移动后** 的指针。
> 3. **执行流**：
>    * 取 `p` 原来的指向 -> 解引用 `*` -> 访问 `.n` -> 得到结果 **5**。
>    * （后台偷偷把 `p` 移到了下一个位置）。

---

## 二、改错题：四大“死穴” (易扣分点)

做改错题时，**不要只盯着语法报错，要盯着逻辑漏洞**。

### 1. 函数返回值的“截肢”惨案
**错题原型：** 求分数序列和。
```c
int func(int n) { ... double s=0.0; ... return s; }
````

**你的无效修改：** 只把 `printf` 里的 `%f` 改成了 `%lf`。

> [!DANGER] 致命错误
> 
> - **根本原因**：函数头写的是 `int`。不管内部 `s` 算是多少 (8.39...)，`return` 的瞬间都会被强制截断为整数 (8)。
>     
> - **外部补救无效**：`main` 函数里怎么改打印格式都没用，因为拿到的已经是整数了。
>     
> - **✅ 正解**：必须修改函数声明 -> `double func(int n)`。
>     

### 2. 交换变量时的“空手套白狼” (野指针)

**错题原型：**

C

```
void swap(int *p1, int *p2) {
    int *p;      // 野指针
    p = *p2;     // ❌ 往野指针里写数据 = 崩溃
    ...
}
```

**你的无效修改：** 把赋值改成了 `*p = *p2` (依然是野指针写入)。

> [!DANGER] 致命错误
> 
> - **根本原因**：`int *p;` 只声明了指针，没分配内存 (`malloc`)，也没指向合法变量。直接用 `*p` 赋值是非法内存访问。
>     
> - **✅ 正解**：
>     
>     1. 中间变量用普通整型：`int temp;`
>         
>     2. 像倒水一样交换：`temp = *p1; *p1 = *p2; *p2 = temp;`
>         
>     3. **别忘了检查 Main 函数**：调用时必须传地址 `swap(&a, &b)`。
>         

### 3. 指针的“指向” vs “拷贝”

**错题原型：** 让 p 指向数组元素 x[4]。

C

```
p = x[4]; // 类型错误 (指针 = 结构体变量)
```

**你的无效修改：** `*p = x[4];` (数据拷贝 + 野指针风险)。

> [!WARNING] 审题关键
> 
> - 题目要求：**“使指针指向...”** -> 操作的是地址。
>     
> - 你的写法：**“把数据拷贝给...”** -> 操作的是值。
>     
> - **✅ 正解**：`p = &x[4];` (或者 `p = x + 4;`)。
>     

### 4. 隐蔽的逻辑错误 (累加 vs 赋值)

**错题原型：** 级数求和循环。

C

```
for(...) { s = (double)a/b; } // ❌ 每次覆盖
```

> [!NOTE] 检查习惯
> 
> - 看到求和 (`sum`)，第一时间检查是不是 `+=`。
>     
> - 看到连乘 (`product`)，第一时间检查是不是 `*=`。
>     

---

## 三、考前急救 CheckList


1. **char 是有符号的**：`0x80` 以上的 char 打印出来是负数。
    
2. **逗号表达式看最后**：但前面的 `++` 都要算。
    
3. **Swap 函数传地址**：中间变量用 `int` 别用 `int*`。
    
4. **指针指结构体**：用 `->`，不要用 `.`。
    
5. **循环右移 N 次**：如果是 N 个元素，结果就是**原封不动**。。