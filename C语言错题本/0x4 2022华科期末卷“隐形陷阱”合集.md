**标签：** #C语言 #错题集 #逻辑陷阱 #位运算 #字符串 #华科期末

## 1. 致命的“未返回值”陷阱
**题目来源：** 2022年改错题第2题 
**场景：** 计算各位数字平方之和。

**你的错误：**
```c
long k = 1; // ❌ 应该为1
do {
    k += (num%10)*(num%10);
    // ...
} while(num);

return k;重点

````

> [!DANGER] 阅卷人视角
> 
> 这是一个典型的“送分变送命”。
> 
> 凡是需要结果的函数，必须有return

**✅ 正确写法：** return k;`

---

## 2. “=” vs “\==”

题目来源： 2022年改错题第3题 

题目要求： “字符串s中位于偶数位置...或者ASCII码为奇数的字符”。

**你的代码 (错误)：**

C

```
if(i%2 = 0 || s[i]%2 != 0) // ❌ i%2=0 是赋值！
```

**解析：**

- **偶数位置 (Even Position)**：指的是下标 `0, 2, 4...`。
    
- **数学表达**：`i % 2 == 0` 。
    
- **你的思维误区**：可能读题快了，混淆了 `!=0` 和 `==0`。
    

**✅ 正确写法：**

C

```
if(i%2 == 0 || s[i]%2 != 0)
```

---

## 3. 结构体数组的“连环跳”

**题目来源：** 2022年第一大题 计算表达式

**数据环境：**

C

```
struct T { int a[3]; ... } b[2] = {
    {{1,2,3}, ...},    // b[0]
    {{-1,0,1}, ...}    // b[1]
}, *p = b; // p 指向 b[0]
```

### 错题 (9): `(p+1)->a[1] ? 1 : 0`

- **你的答案**：`1` (❌)
    
- **正确解析**：
    
    1. `p` 指向 `b[0]`。
        
    2. `p+1` 指向 `b[1]`。
        
    3. `(p+1)->a` 访问的是 `b[1]` 中的数组 `{-1, 0, 1}`。
        
    4. `a[1]` 是数组的第二个元素，也就是 **0**。
        
    5. 表达式变为 `0 ? 1 : 0`。
        
    6. 条件为假，结果为 **0**。
        

### 错题 (6): `++p->a[1]`

- **你的答案**：`0` (❌)
    
- **正确解析**：
    
    1. 优先级：`->` 高于 `++`。所以先算 `p->a[1]`。
        
    2. `p` 指向 `b[0]`，`a` 是 `{1, 2, 3}`。
        
    3. `a[1]` 是 **2**。
        
    4. `++` 前置自增：把这个值加1。
        
    5. 结果为 **3**。
        
    
    - **你的误区**：你可能看错行了，看成了 `b[1]` 里的 `a[1]` (那是0)。**做这种题手指一定要按在当前指针的位置上，不要眼花。**
        

---

## 4. `char` 的符号位陷阱 (Signed vs Unsigned)

**题目来源：** 2022年第一大题 Q1(3)

**题目：** `char d; short y=0xcd; d=y;` 求 `d` 的值。

- **你的初次计算**：`205` (❌)
    
- **你的更正**：`-51` (✅)
    

> [!NOTE] 华科必考知识点
> 
> 在C语言中，单独写 char 通常默认为 signed char (有符号)。
> 
> - `0xcd` 的二进制是 `1100 1101`。
>     
> - 最高位是 `1`，说明是负数。
>     
> - **原码计算 (取反加一)**：
>     
>     - 取反：`0011 0010` (0x32 = 50)
>         
>     - 加一：`51`
>         
>     - 加上负号：`-51`
>         
> - **避坑指南**：如果题目问的是 `%d` 输出或者数值，且最高位是1，一定要转成负数。如果定义是 `unsigned char`，那就是 `205`。
>     

---

## 5. 字符串删除算法 (strstr 的增量搜索)

题目来源： 2022年程序完善题 第2题

题目： 删除所有子串 substr。

**代码片段：**

C

```
char *pch = str;
while ((pch = strstr(____, substr)) != NULL) { // 填空①
    // ...
}
```

- **你的填写**：`str` (❌)
    
- **正确答案**：`pch`
    
- **深度解析**：
    
    - `strstr(haystack, needle)` 从 `haystack` 开始找。
        
    - 如果填 `str`：每次都从字符串**开头**找。假设要删除 "abc" 中的 "a"，第一次找到位置0，处理完后；第二次还是从头找，又找到位置0... **死循环**。
        
    - 填 `pch`：因为在循环体里，`pch` 会被更新指向“当前找到的位置”。虽然题目逻辑比较怪（它是把找到的地方置为 `\0`），但标准逻辑是必须**接着上一次的位置往下找**（或者就在当前位置找，因为当前位置已经被修改了）。
        
    - 在这道题的逻辑里，`pch` 随着循环推进，必须基于当前的指针位置搜索，而不是永远回退到 `str` 开头。
        

---

## 6. 指针的“回马枪”

**题目来源：** 2022年程序分析题 第4题

**代码逻辑：**

C

```
for (i=M; i>0; i--) { ... } // 循环 M 次 (4次)
```

- **陷阱**：数组有 4 个数，循环右移 4 次。
    
- **结果**：移 1 次变样，移 4 次**变回原样**。
    
- **做题技巧**：看到 `N` 个元素的数组进行 `N` 次循环移动，直接写**原数组**，不要浪费时间推导 4 遍！
    
