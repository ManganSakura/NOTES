**标签：** #C语言 #错题集 #指针 #二维数组 #华科期末

## 1. 题目原代码
**题目来源：** 2022年秋C语言期末试卷 A卷 - 程序分析题第5题

```c
#include <stdio.h>

void amov(int *p, int (*a)[3], int n)
{
    int i, j, s=0;
    for (i=0; i<n; i++)
        for(j=0; j<n; j++) {
            *p = (*(a+j))[i];  // <--- 核心难点
            s = s + *p;
            p++;               // <--- 容易搞混的地方
        }
    printf("\ns=%d\n",s);
}

int main()
{
    int i, *p, a[3][3]={{1,3,5},{2,4,6},{7,8,9}};
    p = &a[0][0];
    amov(p, a, 3);
    return 0;
}
````

## 2. 核心考点解析

### A. 复杂指针翻译

- **`*p`**：指向数组的线性存储位置。
    
    - 随着 `p++`，它按顺序遍历：`a[0][0] -> a[0][1] -> a[0][2] -> a[1][0]...`
        
    - **作用**：决定了我们在**写入**哪一个格子。
        
- **`(*(a+j))[i]`**：
    
    - `a+j`：第 `j` 行。
        
    - `*(a+j)`：第 `j` 行首地址。
        
    - `[i]`：取第 `i` 个偏移量。
        
    - **翻译**：等价于 `a[j][i]`。
        
    - **注意**：外层循环是 `i`，内层是 `j`。这意味着我们是在**按列读取**（第0列，第1列...）。
        

### B. 这里的陷阱

> [!DANGER] 致命误区
> 
> 我之前的错误在于把 *p 的赋值（修改当前格子的值）与 p 的移动（指向下一个格子）搞混了。
> 
> 这里的逻辑是：一边读取数组旧值（或新值），一边覆盖写入同一个数组。这是一个原地修改（In-place modification）的过程。

---

## 3. 手动模拟（Trace Code）

**初始矩阵：**

```
1  3  5
2  4  6
7  8  9
```

### 第一轮外循环 (i=0, 读取第0列: 1, 2, 7)

- **j=0**: 读 `a[0][0]`(1) -> 写入 `*p` (此时p指向`a[0][0]`) -> `a[0][0]`变**1**。`s+=1` (s=1)。`p++`。
    
- **j=1**: 读 `a[1][0]`(2) -> 写入 `*p` (此时p指向`a[0][1]`) -> `a[0][1]`变**2** (原值3被覆盖!)。`s+=2` (s=3)。`p++`。
    
- **j=2**: 读 `a[2][0]`(7) -> 写入 `*p` (此时p指向`a[0][2]`) -> `a[0][2]`变**7** (原值5被覆盖!)。`s+=7` (s=10)。`p++`。
    

> [!NOTE] 第一轮结束后的矩阵状态
> 
> 第一行已经被完全改写了，变成了第0列的值。
> 
> ```
> 1  2  7  <-- 被修改
> 2  4  6
> 7  8  9
> ```

### 第二轮外循环 (i=1, 读取第1列)

- **关键点**：此时读取 `a[0][1]` 时，读到的是**刚刚被修改过的 2**，而不是原始的 3！
    
- **j=0**: 读 `a[0][1]`(**2**) -> 写入 `*p` (指向`a[1][0]`) -> `a[1][0]`变**2**。`s+=2` (s=12)。
    
- **j=1**: 读 `a[1][1]`(4) -> 写入 `*p` (指向`a[1][1]`) -> `a[1][1]`变**4**。`s+=4` (s=16)。
    
- **j=2**: 读 `a[2][1]`(8) -> 写入 `*p` (指向`a[1][2]`) -> `a[1][2]`变**8**。`s+=8` (s=24)。
    

> [!NOTE] 第二轮结束后的矩阵状态
> 
> ```
> 1  2  7
> 2  4  8  <-- 被修改
> 7  8  9
> ```

### 第三轮外循环 (i=2, 读取第2列)

- 同样，读取 `a[0][2]` 和 `a[1][2]` 时，都是读的新值。
    
- 最终累加：`s` 继续加 `7`, `8`, `9`。
    
- **最终结果 s = 48**。
    

---

## 4. 总结做题技巧

1. **翻译指针**：看到 `(*(a+j))[i]` 马上在草稿纸上写出 `a[j][i]`。
    
2. **画图并划掉**：遇到这种“读A写A”的题目，绝对不能凭脑子记。
    
    - 画出矩阵。
        
    - 每改写一个数，立马用笔划掉旧值，写上新值。
        
    - 后面的步骤要强制自己去读**新值**。
        
3. **分清 p 的动作**：
    
    - `*p = ...` 是在**改数值**。
        
    - `p++` 是在**挪位置**。