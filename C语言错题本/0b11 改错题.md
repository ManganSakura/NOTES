### 🔥 一、 最“阴险”的语法陷阱 (高频考点)

这些错误往往一眼看不出来，但逻辑完全错了。

#### 1. “赋值”与“等于”混淆 (Top 1 错误)

- **现象**：`if (x = 5)`
    
- **后果**：把 5 赋值给 x，表达式结果为真，**永远执行** if 内的语句。
    
- **修正**：`if (x == 5)`
    

#### 2. 分号的“画蛇添足”

- **现象**：
    
    C
    
    ```
    if (x > 0);  // ❌ 这里多了分号，if 管不住下面了
        x = 0;
    while (x < 10); // ❌ 变成了死循环（如果循环体内没有改x）
        x++;
    ```
    
- **检查**：`if`, `for`, `while` 后面千万别顺手加分号（除非是 `do-while`）。
    

#### 3. 逻辑运算符的短路与优先级

- **现象**：`if (0 < x < 10)`
    
- **后果**：C语言会先算 `0 < x` 得到 0 或 1，再用这个结果去 `< 10`，导致判断恒为真。
    
- **修正**：`if (x > 0 && x < 10)`
    

---

### ☠️ 二、 指针与内存 (程序崩溃区)

这是你之前错题的重灾区，也是得分关键。

#### 1. 指针未初始化 (野指针)

- **现象**：
    
    C
    
    ```
    int *p;
    *p = 10; // ❌ p 指向哪里不知道，直接写入会导致崩溃
    ```
    
- **修正**：必须先指向合法空间（`int a; p = &a;`）或分配内存（`malloc`）。
    

#### 2. 初始化混淆 (你的错题)

- **现象**：`int *p = *a;` 或 `int *p = 100;`
    
- **口诀**：**定义指针时，等号右边必须是地址**。
    
- **修正**：`int *p = a;` 或 `int *p = &n;`
    

#### 3. 返回局部变量地址 (悬空指针)

- **现象**：函数返回了内部定义的数组或变量的地址。
    
- **检查**：看到 `return p;` 或 `return arr;` 时，回头看看 `p` 指向的内存是不是在函数里定义的。如果是 `static` 或 `malloc` 的就没问题，如果是 `int a[10]` 就不行。
    

#### 4. 字符串常量不可改

- **现象**：
    
    C
    
    ```
    char *s = "hello";
    s[0] = 'H'; // ❌ 字符串常量在只读区，修改会崩溃
    ```
    
- **修正**：用数组 `char s[] = "hello";`
    

---

### 🔢 三、 数组与循环 (边界问题)

#### 1. 数组越界与“差一错误” (Off-by-one)

- **现象**：定义 `int a[10]`。
    
- **错误遍历**：`for (i = 0; i <= 10; i++)` (访问了 a[10]，越界)。
    
- **错误倒序**：`while (i != 0)` (往往导致 a[0] 被跳过，**必须用 `>=`**)。
    

#### 2. 字符串结束符 `\0`

- **现象**：手动复制字符串时忘记补 `\0`。
    
- **后果**：`printf` 或 `strlen` 会一直往后读，直到遇到内存里的随机 0 为止，产生乱码或越界。
    
- **修正**：循环结束后一定要 `t[k] = '\0';`。
    

#### 3. `sizeof` 与 `strlen`

- **陷阱**：`char s[] = "abc";`
    
    - `sizeof(s)` 是 **4** (包含 `\0`)。
        
    - `strlen(s)` 是 **3** (不包含 `\0`)。
        
- **易错点**：在函数参数中，数组会退化为指针，`sizeof(arr)` 得到的只是指针大小（4或8字节），而不是数组长度。
    

---

### 💾 四、 类型与运算 (精度丢失)

#### 1. 整数除法 (你笔记里提到的)

- **现象**：`double d = 1 / 2;` -> 结果是 0.0。
    
- **修正**：`1.0 / 2`
    

#### 2. `scanf` 的格式与取地址

- **现象 1**：`scanf("%d", n);` (少写了 `&`) -> **必死**。
    
- **现象 2**：`double d; scanf("%f", &d);` (类型不匹配) -> 数据读入错误。
    
    - `float` 用 `%f`。
        
    - `double` 用 `%lf`。
        
- **现象 3**：`char s[10]; scanf("%s", &s);` (数组名本身就是地址，不需要 `&`，虽不报错但不规范)。
    

---

### 📝 五、 结构体与函数

#### 1. 结构体指针访问

- **现象**：`struct Node *p; ... p.data`
    
- **规则**：
    
    - 是变量用点：`node.data`
        
    - 是指针用箭头：`p->data`
        

#### 2. 函数声明

- **现象**：函数调用在定义之前，且没有在文件开头写声明（原型）。
    
- **后果**：编译器假设返回 `int`，如果实际返回 `double`，结果会出错。
    

---

### 💡 考场做题“三步走”策略

1. **先看“形式”**：
    
    - 有没有分号写错地方？
        
    - `=` 有没有写成 `==`？
        
    - `scanf` 有没有加 `&`？
        
2. **再看“指针”**：
    
    - 指针初始化了吗？
        
    - 有没有把数值赋给指针？
        
    - 有没有越界访问？
        
3. **最后看“逻辑”**：
    
    - 循环能停下来吗？
        
    - 如果是字符串操作，`\0` 处理了吗？
        
    - 数学计算有没有整数截断？
        
