**标签：** #C语言 #二维数组 #命令行参数 #文件操作

## 1. 二维数组的“两幅面孔” (必考表达)

给定 `int a[4][5]`，求 `a[i][j]` 的指针表达式：

| 指针类型 | 定义 | 步长 (Step) | 表达式写法 | 记忆法 |
| :--- | :--- | :--- | :--- | :--- |
| **行指针** | `int (*p)[5] = a;` | 一行 (20字节) | `*(*(p+i)+j)` | **两层皮**：先剥行，再剥列。 |
| **列指针** | `int *p = a[0];` | 一个 (4字节) | `*(p + i*5 + j)` | **一条线**：手动算偏移量。 |

> [!WARNING] 易错警示
> 千万别对行指针 `p1` 用线性公式 `*(p1 + i*5 + j)`，因为 `p1+1` 已经跳了 5 个格子了！

---

## 2. 文件读取的“黄金法则”

**场景**：读取文件数据到数组，最大 N 个。
**错误写法**：
```c
for(i=0; i<N; i++) fscanf(...); // ❌ 强行读N次，无视文件实际长度
````

**正确写法 (模板)**：

C

```
int i = 0;
// 1. 限制数组边界 (i < N)
// 2. 限制文件边界 (fscanf 返回值 == 1)
while (i < N && fscanf(fp, "%d", &a[i]) == 1) {
    i++;
}
// 循环结束后，i 就是实际读取的个数
```

## 3. 命令行参数的安全检查

场景：检查是否有可选参数 -d。

逻辑链条：

1. 先看参数够不够？ (`argc >= 4`)
    
2. 再看参数对不对？ (`strcmp(argv[3], "-d") == 0`)
    

**代码模板**：

C

```
int flag = 1; // 默认升序
// 只有当参数够多，且第三个参数是 -d 时，才改 flag
if (argc >= 4 && strcmp(argv[3], "-d") == 0) {
    flag = 0;
}
```

## 4. 语法微操

- **指针判空**：是 `if (fp != NULL)`，**绝不是** `if (*fp ...)`。
    
- **字符串对比**：`strcmp(str1, str2)`，不是 `*argv[3]` (这是取字符)。